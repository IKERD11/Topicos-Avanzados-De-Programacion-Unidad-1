# 1.2 Tipos de eventos

El esqueleto inerte de una GUI requiere de la Programación Orientada a Eventos (PoE o Event-Driven Programming) para cobrar vida. En este paradigma informático, la CPU y su bloque de memoria principal no monopolizan brutalmente el flujo dictando un camino secuencial rígido (`A -> B -> C`). Por el contrario, el esquema descansa aguardando pasiva y asincrónicamente hasta que un torrente de interrupciones de hardware, paquetes de telecomunicación digital en red, o golpes de teclado del usuario irrumpan alterando caóticamente dicho estado pasivo.

### 1. Mecánica Funcional del Sistema OS: Polling vs Interrupciones

El reconocimiento físico de interacciones ocurre en la capa del Sistema Operativo inferior antes de siquiera rozar el software Python:
*   **Polling (Sondeo Activo Continúo):** Un mecanismo anticuado donde el CPU preguntaba neuróticamente miles de veces por segundo al Mouse: *"¿Te presionaron? ¿Te presionaron?"*. Despedaza severamente el rendimiento y drena las baterías del equipo.
*   **Vector de Interrupciones (Interrupt-Driven):** El paradigma estándar de la computación moderna. El CPU queda inactivo. Cuando el hardware del Mouse completa su conmutador físico eléctrico del clic, dispara una señal eléctrica imperativa obligatoria (`IRQ`) por el bus de la placa madre que detiene bruscamente al CPU. El CPU suspende su quehacer microscópico actual, anexa el suceso, y se lo empuja violentamente a la aplicación de interfaz gráfica en turno (Schildt, 2014).

### 2. La Teoría Omnipresente del Event Loop (Bucle de Mensajes)

Detrás de cada aplicación viva en sistemas como Windows (`Win32 API`), MacOS (`Cocoa`) o navegadores V8, existe una pieza medular invisible perpetua: el **Main Thread** que sostiene un **Event Loop**.
1.  **Cola de Mensajes / Despachos (Message Queue):** Cada interacción genera un paquete diminuto estructurado ("Mouse soltado en las coord X:150, Y:30 con flag izq"). Esto se apila brutalmente en una fila inmensa sin procesar que crece segundo a segundo.
2.  **Despachador Infatigable (Dispatcher):** Flet reside en un bucle `while True` eterno interno. Absorbe frenéticamente el mensaje de tope de cola, y mapea para dilucidar con geometría matricial si esas coordenadas chocan exactamente con algún control renderizado donde el nosotros (los programadores) hayamos instalado un cable receptor (callback). Si los encuentra colisionando, gatilla el algoritmo respectivo.

### 3. Anatomía del Flujo: Propagación, Burbujeo y Delegación
Si el humano clickea "Guardar" en una tarjeta que agrupa varios recuadros que, a su vez, habitan en un contenedor global inmenso dentro de la ventana suprema... ¿A quién le pertenece ese toque orgánicamente?
*   **Capturing Phase (Fase de Inmersión o Zócalo descendente):** Conceptualmente, la energía del impacto perfora entrando desde la Ventana Padre Suprema e inyectándose verticalmente capa a capa inferiormente atravesando paneles hasta chocar físicamente y llegar al elemento más microscópico tocado.
*   **Bubbling Phase (Fase de Burbujeo de Retorno Ascendente):** Tras impactar violentamente el corazón (el Botón Guardar), este detona. Acto seguido y sistemático, el evento revienta rebotando al revés (de inferior, para arriba) como una burbuja subacuática hacia sus elementos genitores. Afectando que, si la "Ventana Principal" tenía programado globalmente disparar un ruido molesto a "Cualquier Clic General", dicho disparo sucederá por contagio de subida (Bubbling).
*   **Detención de Propagación (`e.stopPropagation()` / `e.cancelBubble`):** Arquitectos expertos cortan, aniquilan o asesinan el flag de propagación tras validar la operación para que dicho rebote de la burbuja y su contagio jamás infeste e interfiera subiendo de nuevo hacia partes ajenas de una parentela indeseada en el DOM.

### 4. Taxonomía Exhaustiva Categórica Operativa de Tipos de Eventos

En entornos y documentaciones ricas maduras, se categorizan las intenciones paramétricas del usuario según sus naturalezas elementales:

#### A. Eventos Físicos Secos Punitivos (Kinestésicos Inmediatos de Hardware)
*   **Micro-Estados Crudos del Puntero / Cursor (Gestos Puros):**
    *   `on_mouse_down` y `on_mouse_up`: Clic fragmentado. Una operación arrastrable *Drag & Drop* no ocurre con `on_click`, necesita entender el aplastado sostenido previo individual desvinculado de que el botón primario fuera soltado a 30 centímetros lejos arrastrado sobre otra gráfica contraria.
    *   `on_click` | `on_tap`: Fusión inseparable indivisible atada al clic íntegro; es decir: debe obligatoriamente deprimirse y también soltarse con validación positiva de éxito exacto recíproco y geográficamente sobre el mismo cajón visual preestablecido.
    *   `on_hover` | `on_enter` | `on_exit`: Intersecciones matemáticas abstractas y transgresiones puramente dimensionales de sombras sin opresión mecánica física. Imprescindible en el 100% vital para desplegar Tooltips oscuros (etiquetas chiquitas flotantes de guía amarillas) demostrando accesibilidad.

*   **Intercepción Periférica Mecanografiada (KeyCodes Raw y Chording):**
    *   `page.on_keyboard_event`: Escucha pasiva, letal y omnisciente. Recolecta códigos ASCII originados en la CPU. Útil en escenarios en los que Flet deba interceptar pulsos de "Esc" o "Tabulación" o detectar uso combinado pesado (*Chording* como unificar simultáneamente "Ctrl + Shift + T") en utilerías complejas. 

#### B. Eventos Semánticos o de Transición Informática Indirecta
Los más utilizados en la industria del software. Transcienden el hardware e importan solo "la mutación del estado del software subyacente de negocios" sin importar exactamente el qué forzó a alterarlo.
*   **Eventos Vitales de Mutabilidad Transitiva Continua (`on_change`):**
    Cuando un objeto transmuta interinamente desde que partió ("1") al nuevo status ("12"). Disparados ráfagas formidables miles de veces desde listas plegables o `TextFields` y selectores de rangos de volumen.
*   **Señales de Foco Alternado Direccional (`on_focus` y `on_blur`):**
    Gobierna la directriz que dicta dónde encauzará primariamente la vía del puntero interno textual en caso de ingresar tipeos futuros en la RAM. `Focus` es "mirar" orgánicamente a un componente habilitando la escritura de su línea de pulso asimétrico de rayita que destella parpadeante constante (`|`). `Blur` se dispara cruelmente el único y valioso milisegundo absoluto donde el usuario hace un clic falso torpe o un abandono saltado tabulado hacia afuera exiliándose de las paredes del componente, escenario sagrado y único adecuado para validar en frío los algoritmos matemáticos en vez de castigar a la letra letra validando la máquina a cada coma tipeada.

#### C. Control Integral Soberano de Contextos, Ventanas y Operativos Locales Host
Son notificaciones puras operacionales de contingencias sobre eventos donde Flet advierte a nuestro código interno Python sobre alteraciones en la carcasa macro-exterior dictaminadas estribadas por Windows, Linux, MacOS o su respectivo servidor de la Nube (Cloud Connection).
*   **Eventos Disrupotores de Redimiensionamiento Topológico Global (`page.on_resize`):** Windows arroja este evento de un modo letal agresivo continuo por la eternidad y cada pequeña fracción variable que sufra el ensanchamiento en tiempo real si el operador manipula estirando bruscamente la pestaña para visualizar al mismo par en 50/50 la pantalla con otro procesador de hojas. Sin ellos para reajustar medidas y porcentualidades automáticas por evento el software moderno choca y la resolución estalla rompiéndose y amontonando componentes rotos estáticos perdiéndose a esquinas ciegas invisibles.
*   **Desgarramientos Transmisivos Web (`page.on_disconnect` / `on_connect`):** Alertan estrepitosamente informando cuando la tarjeta de red Wi-Fi ajena ha desconectado o matado violentamente un enlace que fluía entre nuestra parte cliente alojada visual Web de la app móvil cortando su cable de abasto invisible hacia nuestros algoritmos backend del código de base Python.

### 5. Código Práctico: Laboratorio de Captura de Múltiples Eventos

El siguiente script Flet demuestra la implementación real de la teoría explicada, combinando eventos de teclado globales, enfoque en campos de texto, ruteo semántico y eventos al pasar el puntero (Hover):

```python
import flet as ft

def main(page: ft.Page):
    page.title = "Laboratorio Práctico de Eventos"
    page.padding = 30

    # 1. Evento de Ventana Global (Teclado)
    def manejar_teclado_global(e: ft.KeyboardEvent):
        if e.key == "Escape":
            etiqueta_estado.value = "Estado: ¡El operador abortó con ESC!"
            etiqueta_estado.color = ft.colors.RED
            page.update()

    page.on_keyboard_event = manejar_teclado_global

    # 2. Eventos Semánticos (Foco y Desenfoque)
    def entrar_foco(e):
        e.control.bgcolor = ft.colors.BLUE_50
        e.control.update()

    def perder_foco(e):
        e.control.bgcolor = None # Se restaura el fondo
        
        # Validando al salir, no tecleo por tecleo
        if "@" not in e.control.value and len(e.control.value) > 0:
            e.control.error_text = "Falta el arroba (@)"
        else:
            e.control.error_text = None
        e.control.update()

    campo_correo = ft.TextField(
        label="Correo Institucional",
        on_focus=entrar_foco,
        on_blur=perder_foco
    )

    # 3. Evento Físico Direccional (Hovering)
    def contenedor_animado_hover(e):
        # e.data es 'true' (string en Flet) si cruzó entrando, 'false' si salió
        e.control.bgcolor = ft.colors.GREEN_100 if e.data == "true" else ft.colors.GREEN_50
        e.control.update()

    caja_interactiva = ft.Container(
        content=ft.Text("Pasa el mouse sobre mí (Hover)"),
        padding=20,
        bgcolor=ft.colors.GREEN_50,
        border_radius=10,
        on_hover=contenedor_animado_hover,
        ink=True # Efecto de onda nativo en clicks
    )

    etiqueta_estado = ft.Text("Estado: Esperando interacciones...")

    # Embalaje Virtual
    page.add(
        etiqueta_estado,
        ft.Divider(),
        campo_correo,
        caja_interactiva,
        ft.Text("Presiona la tecla ESC para activar el evento global.", italic=True)
    )

ft.app(target=main)
```

---

### Referencias Bibliográficas

Flet. (2024). *Keyboard events - Flet Guide*. Recuperado de https://flet.dev/docs/guides/python/keyboard-events/

Petzold, C. (1998). *Programming Windows* (5th ed.). Microsoft Press. (Obra maestra fundacional sobre arquitecturas de mensajería interna, ventanas y el Event Loop a bajo nivel en API puras).

Schildt, H. (2014). *Java: The Complete Reference* (9th ed.). McGraw-Hill Education.

Stroustrup, B. (2013). *The C++ Programming Language* (4th ed.). Addison-Wesley. (Perspectivas de hardware y punteros en interrupciones base de interacciones de hardware y periféricos crudos).
