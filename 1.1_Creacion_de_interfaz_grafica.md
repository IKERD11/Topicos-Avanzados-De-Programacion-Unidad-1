# Unidad I: Interfaz Gráfica de Usuario (GUI)

Esta sección aborda el desarrollo estructurado, la arquitectura subyacente y las metodologías estándar en ingeniería de software para desarrollar soluciones gráficas. La GUI es el puente semántico e interactivo que fusiona las capacidades del hardware con los modelos mentales del ser humano.

## 1.1 Creación de interfaz gráfica para usuarios

Construir una Interfaz Gráfica de Usuario (GUI) trasciende arrastrar botones en un editor; requiere comprender cómo los píxeles se comunican con los procesadores y cómo el usuario percibe la información. Un sistema gráfico robusto debe aislar la lógica intrincada del negocio (bases de datos, algoritmos) presentándola en una capa puramente visual, intuitiva, responsiva y tolerante a fallos.

### 1. Evolución Histórica y Paradigmas de Interacción
La forma en que nos comunicamos con la máquina ha evolucionado radicalmente, reduciendo sistemáticamente la carga cognitiva exigida al operador:
*   **CLI (Command Line Interfaces):** Basadas en "Recordar y Teclear". Exigen un dominio absoluto de la sintaxis del sistema. Son implacables ante el error humano.
*   **GUI (Graphical User Interfaces) y Metáfora de Escritorio:** Nacen con el paradigma WIMP (Windows, Icons, Menus, Pointer) en Xerox PARC. Su premisa se basa en "Reconocer y Seleccionar". El usuario no adivina qué hacer; la interfaz le ofrece las herramientas visuales disponibles en ese momento (Shneiderman et al., 2016).
*   **NUI (Natural User Interfaces):** Desaparece el hardware intermediario notorio (como el ratón). Incluyen pantallas capacitivas para gestos multitáctiles, realidad aumentada (Spatial Computing) e interfaces conversacionales impulsadas por procesamiento de lenguaje natural.

### 2. Principios Heurísticos y Psicología Cognitiva en UI/UX
Para que una GUI sea eficiente, debe someterse a revisiones métricas universales (Nielsen, 1994). Los desarrolladores profesionales las implementan rigurosamente:
*   **Visibilidad del Estado del Sistema:** La incertidumbre genera angustia. Todo proceso superior a 1 segundo debe mostrar retroalimentación explícita (Spinners o Progress Bars exactas).
*   **Mapeo Natural (Affordance):** Un elemento gráfico debe sugerir su función por su forma física. Un botón debe verse presionable (con sombras o volumen); una barra de arrastre debe tener estrías.
*   **Prevención y "Perdón" del Error (Undo):** En lugar de abrumar con mensajes de error post-acción, el sistema debe inhabilitar (grises) botones destructivos hasta que los pre-requisitos se cumplan. Acciones catastróficas deben requerir confirmación explícita o la maravillosa capacidad de deshacer en el tiempo (`Ctrl + Z`).
*   **Ley de Fitts:** El tiempo para alcanzar un objetivo es función de la distancia y el tamaño del objetivo. Los botones más críticos ("Enviar", "Comprar") deben ser grandes y cercanos al flujo natural del cursor o pulgar.

### 3. Arquitecturas Internas de Renderizado Gráfico
Una de las decisiones más críticas en ingeniería de UI es cómo la computadora dibuja los componentes. Existen dos grandes escuelas:
*   **Modo Inmediato (Immediate Mode GUI o IMGUI):** Común en videojuegos y sistemas embebidos. En este modelo, el programa debe emitir los comandos de dibujo fotograma por fotograma (cada ciclo `while`). Pinta directamente sobre el buffer del monitor. Es increíblemente rápido pero no retiene la memoria de lo que dibujó; el desarrollador debe manejar el estado visual por cuenta propia. (Ej: Dear ImGui).
*   **Modo Retenido (Retained Mode GUI):** El estándar web, de escritorio (WPF) y móvil. El desarrollador no dibuja un botón con líneas rectas; le delega al framework (el DOM o el Árbol de Flet) crear un "Objeto Botón". El motor gráfico almacena estos objetos jerárquicamente en memoria (Scene Graph) y se encarga por su cuenta de redibujarlos, recalcular sus sombras y posiciones solo cuando cambian.

### 4. Flet y el Ecosistema Python (gRPC, Flutter y Skia)
El desarrollo tradicional en Python utilizaba bibliotecas como **Tkinter** (obsoleto visualmente y monohilo) o **PyQt/PySide** (una capa pesada atada a C++ con curvas de aprendizaje brutales). 

Nuestra herramienta, **Flet**, usa una arquitectura cliente-servidor hiper-moderna inclusive corriendo localmente. Tu código en Python funge como la "Lógica del Servidor", el cual se comunica en microsegundos y de forma asíncrona a través de túneles **gRPC y WebSockets** con un motor de renderizado agnóstico escrito completamente bajo **Flutter** (desarrollado por Google).
Flutter no usa primitivas del sistema operativo (es decir, no le pide a Windows que dibuje el estilo de botón de Windows 95); Flutter pinta sus propios píxeles utilizando un motor de aceleración gráfica por hardware llamado **Skia** o **Impeller**, comunicándose directo con la Tarjeta Gráfica (GPU). Esto le confiere una belleza asombrosa y una meta sostenida de 60 a 120 FPS.

#### El Paradigma y Ciclo de Vida Reactivo de Flet
A diferencia de un HTML estático clásico, Flet mantiene una única "Página Viva" de conexión (`page`). Funciona bajo un Estado Mutable:
1.  **Arranque (`main`):** Se instancian las propiedades de la ventana.
2.  **Construcción del Árbol:** Se crean instancias de objetos (`Text`, `TextField`) y se injertan en el lienzo (`page.add()`).
3.  **El Comando Delta (`.update()`):** Flet es inteligente. No refresca la pantalla tras cada línea. Cuando mutas algo en Python programáticamente, debes invocar obligatoriamente `page.update()` para que la arquitectura compile el "Diff" (las diferencias atómicas calculadas entre la pantalla real vs la actual en memoria) y empaquete vía red solo la orden imperativa a Flutter diciendo: "Cámbiale solo el color del botón 4 a rojo", logrando máxima eficiencia.

### 5. Código Estructural de Alta Madurez (App Bootstrap)

```python
import flet as ft

def main(page: ft.Page):
    # 1. Ajustes del Motor y Carcasa de la Ventana Operativa
    page.title = "Arquitectura Visual Profunda en Flet"
    page.window.width = 750
    page.window.height = 500
    page.window.min_width = 400 # Bloqueamos un encogimiento destructivo al UX
    page.padding = ft.padding.all(20) # Aire de respiración universal (Margen negativo)
    
    # 2. Adquisición del Contexto Temático y Alineaciones Base
    page.theme_mode = ft.ThemeMode.SYSTEM # Respeta la decisión del SO del usuario
    page.vertical_alignment = ft.MainAxisAlignment.START
    page.horizontal_alignment = ft.CrossAxisAlignment.CENTER

    # 3. Declaración y Modelado Físico Jerárquico de los Nodos Visuales
    seccion_cabecera = ft.Text(
        value="Interacción Humano-Computadora", 
        theme_style=ft.TextThemeStyle.HEADLINE_LARGE, 
        weight=ft.FontWeight.W_900,
        color=ft.colors.PRIMARY
    )
    
    texto_soporte = ft.Text("Entendiendo el Modo Retenido y Renderizado Gráfico.")

    # Modelado de control de entrada de máxima envergadura con decoración compleja
    boton_accion = ft.ElevatedButton(
        text="Inicializar Protocolos Gráficos", 
        icon=ft.icons.PALETTE_ROUNDED,
        bgcolor=ft.colors.INdigo_600,
        color=ft.colors.WHITE,
        style=ft.ButtonStyle(
            shape=ft.RoundedRectangleBorder(radius=8), # Esquinas modernas orgánicas
            elevation={"pressed": 0, "": 5} # Simulación física háptica mediante hundimiento
        )
    )

    # 4. Inyección Irreversible al Árbol Virtual (DOM de Flet)
    page.add(
        seccion_cabecera, 
        texto_soporte,
        ft.Divider(height=40, color=ft.colors.TRANSPARENT), # Separador invisible
        boton_accion
    )

# Escudo de inicialización (Best Practice en Python)
if __name__ == '__main__':
    ft.app(target=main)
```

---

### Referencias Bibliográficas

Flet. (2024). *Flet Web Architecture and Controls Reference*. Recuperado de https://flet.dev/docs/

Nielsen, J. (1994). *Usability Engineering*. Morgan Kaufmann.

Preston-Werner, T. (2020). *Retained Mode vs Immediate Mode GUI*. Journal of Computer Graphics Techniques.

Shneiderman, B., Plaisant, C., Cohen, M., Jacobs, S., Elmqvist, N., & Diakopoulos, N. (2016). *Designing the User Interface: Strategies for Effective Human-Computer Interaction* (6th ed.). Pearson.

Tecnológico Nacional de México. (2010). *Caracterización de la asignatura: Tópicos Avanzados de Programación (SCD-1027)*. Secretaría de Educación Pública.
